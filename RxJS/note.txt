Thu Oct 13, 2022.
1. RxJS Overview (Reactive Extensions for JS)
    -> RxJS is a library for composing async and event-based programs by using observable sequences.
    -> It provides once core type, the Observable, satellite types and operators to allow handling async events as collections.
    -> Conveniently handling async code.
2. What is Observables ?
    -> The Observables are like data or event generators with some logic stored inside.
    -> any data can be converted into an Observable.
    -> to run the code placed inside of an Observable, we need to subscribe it.
3. What is a stream ?
    -> The Observables are based around the idea of streams, which means that the data can come at various points of time and the number of emitted values might be infinite.
    -> stream is different to array
        - items in a stream can come at various points of time.
        - reacting to the things as they show up, we dont know the next value and whether it will appear at all.
4. Observable.
    ->  single callback function with a set of rules.
    -> Once the Observable is executed, it can emit some notifications,
        - next: emit value
        - error:
        - complete:
    -> Observer: next function in the observer provides the behavior for the next notifications emitted by the observable.
    -> Subscription is what executes the Observable.
        - it runs the callback inside the Observable and passes to Observer object.
        - Each Observable exposes the subscribe method, so to start a new Subscription, we simply call the subscribe method on the Observable and pass the Observer as an argument.
        - observable$.subscribe(observer);
        -  the subscribe method gets called on our Observable that we created
            (new subscription is made, which means that the callback in the observable run with the provided observer converted in to a subscriber object.)
        - each new subscription runs the Observable with the provided observer and each emitted value by the observable will call the observer's next handler with the provided value. then observer will do its work.

============================================================================================================================================================================================================================
Fri Oct 14, 2002
1. The notifications that can be emitted by the observable. (Marble Diagram => Next Notification / Complete Notification / error Notification)
    -> Next: shows emit
    -> Complete: shows complete : dont carry payload
    -> Error: ends subscription: can carry payload
    - No other notification after complete and error.

============================================================================================================================================================================================================================
Tue Oct 18, 2022
1. Tear Down
    -> Tear-Down logic can be used by Observable to clean up after itself to prevent memory leaks or to provide cancellation logic
    -> eg.) If we had an Observable which would call the server using HTTP request, we could abort that HTTP request in the teardown login
2. Order
    -> 1. Order => Error > next & complete by setTimeout
        - situation: the value and complete notification emitted after the error happens
        - Error notification ends the subscription, which means there can be no more emissions
        - intermediate subscriber obj, created automatically by RxJS, checks whether the subscription is still active before passing the notification.
        - So this subscriber obj works like a safety fuse and ensures that Observables and subscription  always work in a designed way.
3. Cancellation
    ->   if , this teardown logic is null, the code inside  the observable is still running => no more code / memory leaks.
============================================================================================================================================================================================================================
Wed Oct 19, 2022
1. Types of Observables, depending on the source of emissions.
    -> Hot Observables: Observables logic connects to some common, shared source (e.g. DOM event)
    -> Cold Observables:  started a new interval and then produced the values based on the interval created.

2. Cold Observables:
    -> Observables which wwe subscribe, produced and emitted values ->  created an Observables independently.
    -> All values were produced separately, independently for each subscription.
3. Hot Observables
    -> all subscription share the same sources.
    -> It just connects to some existing source.
    -> The actual source of the emissions is placed outside the observables' logic, we just connect event.
    -> Each new subscription is adding a new listener to the event.
    => Hot Observables is the one which has the actual source of the emissions placed outside it, and the observable logic just adds another connection to this source.
4. Hot and Cold Observables/
    -> COLD:
        - Produces the data inside.
        - New Subscriber - new Data
        - E.G.: Set of values / HTTP request /Time&Interval
    -> HOT:
        - Multicasts the data from a common source (outside).
        - All subscribers - common data
        - E.G: DOM events/ state of the app / subjects (part of rxjs library)

============================================================================================================================================================================================================================
Thu Oct 20, 2022
1. Creation Functions
    -> provides an easy way to create a new observable with certain behavior.ÃŸ
    -> e.g) of / from / fromEvent / interval/timer / forkJoin / combineLatest
2. of - How Creation function work.
    ->  of creation function allows us to creaate an observable, which emits a set of values and completes, so when we subscribe to such observable, all values that we have provided as arguments will be emitted immediately as next notifications, and then, the observable will complete, ending the subscription.
3. From CF
    -> Convert other types into an observable.
    -> From can be used in Array, promise, and others
============================================================================================================================================================================================================================
Fri Oct 21, 2022
1. fromEvent:
    -> allows us to create an Observable from various event sources, including, multiple targets from DOM to jQuery
2. timer:
    -> Timer Creation Function allows us to create an Observable which will wait some time, emit a value and complete.
3. interval
    -> not a single timeout ( same as setInterval function)
============================================================================================================================================================================================================================
Mon Oct 24, 2022
1. forkJoin
    -> when all observables complete, emit the last emitted value from each.
    -> Error in a single observable will cause other observables to be cancelled.
    -> 'forkJoin' allowed us to wait for all the Observables to complete before our emitting
2. combineLatest
    ->  kept emitting the latest known set of values each time any of the provided input Observables emitted something new.
    -> combineLatest needs at least one value from each source before it emits something.
3. pipeable operators
    ->  they allow us to transform the notifications emitted by an Observable in countless ways.
    -> enable us to write complex async logic easily.
    -> Pipeable Operator, takes what it has above as that input.
============================================================================================================================================================================================================================
Tue Oct 25, 2022
1. Tap
    -> Tap operator works like a spy and allow us to cause some side effects without interacting with the notifications.
    -> It is useful if we have multiple operators stacked and we would like to be able to observe the notifications at ant stage of this operatros;'s pipeline to.
2. debounce time
    -> The 'debounceTime' operator would wait for the emissions to settle down, and after two seconds of no new emissions, it would reemit just the latest value.
     -> This is useful to avoid putting excessive pressure on some recalculation logic to avoid performance
     -> issues or, for example, to reduce the frequency of HTTP requests sent to the server.
============================================================================================================================================================================================================================
Wed Oct 26, 2022
1. catchError operator:
    -> provide a fallback source in case the original source fails.
    -> so, operator will not change the emitted values and complete notification.
    -> use EMPTY operator, to hide error notification from your observer.
2. Flattening operators:
    -> The Flattening Operators create new inner Subscriptions to the provided Observables generated based on the next notifications received from the source. Then, they pass the emitted values from those inner Subscriptions to the output.
    -> In other words, the Flattening Operator will react to a next notification by creating a new inner Subscription to the provided Observable.
3. concatMap
    -> https://boxfoxs.tistory.com/413